# -*- coding: utf-8 -*-
"""cricket analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FVxEVso0QXekqV8UxLMFt7pD057sz41L
"""



"""**Player Performance Analysis**


"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans

deliveries = pd.read_csv('deliveries.csv')
matches = pd.read_csv('matches.csv')

# Total runs scored by each batter
batter_stats = deliveries.groupby('batter').agg(
    matches_played=('match_id', pd.Series.nunique),
    total_runs=('batsman_runs', 'sum'),
    balls_faced=('ball', 'count'),
    fours=('batsman_runs', lambda x: (x == 4).sum()),
    sixes=('batsman_runs', lambda x: (x == 6).sum())
).reset_index()

batter_stats['strike_rate'] = (batter_stats['total_runs'] / batter_stats['balls_faced']) * 100
batter_stats['boundary_percent'] = ((batter_stats['fours'] + batter_stats['sixes']) / batter_stats['balls_faced']) * 100

# Filter batters with at least 200 balls faced
batter_stats = batter_stats[batter_stats['balls_faced'] >= 200]

# Filter only legitimate deliveries
valid_deliveries = deliveries[~deliveries['extras_type'].isin(['wides', 'noballs'])]

bowler_stats = valid_deliveries.groupby('bowler').agg(
    total_runs_conceded=('total_runs', 'sum'),
    balls_bowled=('ball', 'count'),
    wickets=('player_dismissed', lambda x: x.notna().sum()),
    dot_balls=('total_runs', lambda x: (x == 0).sum())
).reset_index()

bowler_stats['overs'] = bowler_stats['balls_bowled'] // 6
bowler_stats = bowler_stats[bowler_stats['overs'] > 10]  # Filter for regular bowlers

bowler_stats['economy'] = bowler_stats['total_runs_conceded'] / bowler_stats['overs']
bowler_stats['strike_rate'] = bowler_stats['balls_bowled'] / bowler_stats['wickets']
bowler_stats['dot_ball_percent'] = (bowler_stats['dot_balls'] / bowler_stats['balls_bowled']) * 100

all_rounders = pd.merge(batter_stats[['batter', 'total_runs']],
                        bowler_stats[['bowler', 'wickets']],
                        left_on='batter', right_on='bowler')

all_rounders['performance_score'] = (all_rounders['total_runs'] / all_rounders['total_runs'].max()) + \
                                    (all_rounders['wickets'] / all_rounders['wickets'].max())

all_rounders.sort_values('performance_score', ascending=False).head(10)

# Dummy average (you need to compute dismissals to calculate real average)
# For now, use total_runs / matches_played
batter_stats['batting_avg'] = batter_stats['total_runs'] / batter_stats['matches_played']

sns.scatterplot(data=batter_stats, x='strike_rate', y='batting_avg', size='total_runs', hue='boundary_percent', palette='viridis')
plt.title('Batting Average vs Strike Rate')
plt.xlabel('Strike Rate')
plt.ylabel('Batting Average')
plt.show()

from sklearn.preprocessing import StandardScaler

features = batter_stats[['strike_rate', 'batting_avg', 'boundary_percent']]
scaler = StandardScaler()
scaled_features = scaler.fit_transform(features)

kmeans = KMeans(n_clusters=4, random_state=42)
batter_stats['cluster'] = kmeans.fit_predict(scaled_features)

sns.scatterplot(data=batter_stats, x='strike_rate', y='batting_avg', hue='cluster', palette='Set2')
plt.title('Batter Clusters (K-Means)')
plt.show()



"""**Venue & City Insights**"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px



# First innings only
first_innings = deliveries[deliveries['inning'] == 1]
first_innings_runs = first_innings.groupby('match_id')['total_runs'].sum().reset_index()

# Merge with match metadata
merged = matches.rename(columns={'id': 'match_id'}).merge(first_innings_runs, on='match_id')

# Group by city
city_avg_scores = merged.groupby('city')['total_runs'].mean().sort_values(ascending=False).reset_index()

# Plot
plt.figure(figsize=(12,6))
sns.barplot(x='total_runs', y='city', data=city_avg_scores, palette='viridis')
plt.title('üèôÔ∏è Average First Innings Score by City')
plt.xlabel('Average Runs')
plt.ylabel('City')
plt.tight_layout()
plt.show()

venue_avg_scores = merged.groupby('venue')['total_runs'].mean().sort_values(ascending=False).reset_index()

plt.figure(figsize=(12,8))
sns.barplot(x='total_runs', y='venue', data=venue_avg_scores.head(10), palette='rocket')
plt.title('Top 10 Batting-Friendly Venues (Avg 1st Inn Score)')
plt.xlabel('Average Runs')
plt.ylabel('Venue')
plt.tight_layout()
plt.show()

# Create match result from toss
matches['toss_win_match_win'] = matches['toss_winner'] == matches['winner']
toss_impact = matches.groupby('venue')['toss_win_match_win'].mean().reset_index()
toss_impact.columns = ['venue', 'toss_win_success_rate']

plt.figure(figsize=(12,6))
sns.barplot(x='toss_win_success_rate', y='venue', data=toss_impact.sort_values(by='toss_win_success_rate', ascending=False).head(10), palette='coolwarm')
plt.title('Top 10 Venues Where Toss Winning Often Leads to Match Win')
plt.xlabel('Toss Win to Match Win Rate')
plt.ylabel('Venue')
plt.tight_layout()
plt.show()

outcomes_by_city = matches.groupby(['city', 'result']).size().unstack().fillna(0)

plt.figure(figsize=(10,6))
sns.heatmap(outcomes_by_city, annot=True, cmap='YlGnBu', fmt='g')
plt.title("Match Outcomes by City")
plt.ylabel("City")
plt.xlabel("Result Type")
plt.tight_layout()
plt.show()

fig = px.density_heatmap(
    outcomes_by_city.reset_index().melt(id_vars="city"),
    x="result", y="city", z="value", color_continuous_scale="Viridis",
    title="Match Outcomes by City (Interactive)"
)
fig.show()



"""**Toss & Match Outcome Impact**"""

#Toss-Winning Increase Match-Winning Chances: (Chi-Square Test)
import pandas as pd
from scipy.stats import chi2_contingency

# Toss win vs match win: Create a contingency table
contingency = pd.crosstab(matches['toss_winner'] == matches['winner'], columns="count")
print("Contingency Table:\n", contingency)

# Chi-square test
chi2, p, dof, expected = chi2_contingency(contingency)
print(f"\nChi-Square Test Result:\nChi2 Stat = {chi2:.3f}, p-value = {p:.3f}")

if p < 0.05:
    print("‚úÖ Toss result and match outcome are significantly associated (p < 0.05)")
else:
    print("‚ùå No significant association between toss and match outcome (p >= 0.05)")

#Toss Decision Trends (Bat vs Field) Over Seasons
import seaborn as sns
import matplotlib.pyplot as plt

# Count of toss decisions by season
plt.figure(figsize=(12,6))
sns.countplot(data=matches, x='season', hue='toss_decision', palette='Set2')
plt.title("Toss Decisions Over Seasons")
plt.xlabel("Season")
plt.ylabel("Count")
plt.xticks(rotation=45)
plt.legend(title="Toss Decision")
plt.tight_layout()
plt.show()

#Toss Decision Trends (Bat vs Field) Over Seasons
import seaborn as sns
import matplotlib.pyplot as plt

# Count of toss decisions by season
plt.figure(figsize=(12,6))
sns.countplot(data=matches, x='season', hue='toss_decision', palette='Set2')
plt.title("Toss Decisions Over Seasons")
plt.xlabel("Season")
plt.ylabel("Count")
plt.xticks(rotation=45)
plt.legend(title="Toss Decision")
plt.tight_layout()
plt.show()

# Top 10 venues by matches played
top_venues = matches['venue'].value_counts().nlargest(10).index
venue_trends = matches[matches['venue'].isin(top_venues)]

plt.figure(figsize=(12,6))
sns.countplot(data=venue_trends, y='venue', hue='toss_decision', palette='pastel')
plt.title("Toss Decisions at Top 10 Venues")
plt.xlabel("Count")
plt.ylabel("Venue")
plt.tight_layout()
plt.show()

#Predicting Match Winner Using Decision Tree
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import numpy as np

# Copy data and drop null match results
df = matches.dropna(subset=['winner'])

# Features: team1, team2, toss_winner, toss_decision, city, venue
features = df[['team1', 'team2', 'toss_winner', 'toss_decision', 'city', 'venue']]
target = df['winner']

# Label encoding
le = LabelEncoder()
for col in features.columns:
    features[col] = le.fit_transform(features[col].astype(str))
target = le.fit_transform(target.astype(str))

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42)

# Train Decision Tree
model = DecisionTreeClassifier(max_depth=4, random_state=42)
model.fit(X_train, y_train)

# Accuracy
accuracy = model.score(X_test, y_test)
print(f"Decision Tree Accuracy: {accuracy:.2f}")

# Plot the tree
plt.figure(figsize=(20,10))
plot_tree(model, feature_names=features.columns, class_names=np.unique(df['winner']).astype(str), filled=True)
plt.title("Decision Tree to Predict Match Winner")
plt.show()



"""**Run Rate & Overwise Momentum**"""

#Over-wise Scoring Patterns by Phase
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Add 'phase' column based on over number
def get_phase(over):
    if over <= 6:
        return 'Powerplay'
    elif 7 <= over <= 15:
        return 'Middle'
    else:
        return 'Death'

deliveries['phase'] = deliveries['over'].apply(get_phase)

# Group by phase
phase_runs = deliveries.groupby('phase')['total_runs'].mean().reset_index()

# Plot
plt.figure(figsize=(8, 5))
sns.barplot(x='phase', y='total_runs', data=phase_runs, palette='viridis')
plt.title("Average Runs per Phase")
plt.xlabel("Match Phase")
plt.ylabel("Avg Runs per Over")
plt.tight_layout()
plt.show()

# Choose one match to analyze
match_id = deliveries['match_id'].unique()[0]  # or manually select a match ID

match_data = deliveries[deliveries['match_id'] == match_id]

# Group over-wise for both innings
momentum = match_data.groupby(['inning', 'over'])['total_runs'].sum().reset_index()

plt.figure(figsize=(10, 6))
sns.lineplot(data=momentum, x='over', y='total_runs', hue='inning', marker='o')
plt.title(f"Overwise Momentum Curve ‚Äì Match ID {match_id}")
plt.xlabel("Over")
plt.ylabel("Runs Scored")
plt.legend(title="Inning")
plt.grid(True)
plt.tight_layout()
plt.show()

# Average run rate per over across all matches and innings
avg_runrate = deliveries.groupby(['inning', 'over'])['total_runs'].mean().reset_index()

# Calculate 3-over rolling average (momentum smoothing)
avg_runrate['rolling_rr'] = avg_runrate.groupby('inning')['total_runs'].transform(lambda x: x.rolling(3, min_periods=1).mean())

# Plot
plt.figure(figsize=(10, 5))
sns.lineplot(data=avg_runrate, x='over', y='rolling_rr', hue='inning', marker='o')
plt.title("Smoothed Overwise Run Rate (Rolling Avg over 3 overs)")
plt.xlabel("Over")
plt.ylabel("Rolling Run Rate")
plt.grid(True)
plt.tight_layout()
plt.show()

# Determine innings type based on inning number
def classify_inning(inning):
    if inning == 1:
        return 'Defending'
    else:
        return 'Chasing'

deliveries['inning_type'] = deliveries['inning'].apply(classify_inning)

# Group over-wise run rate by inning type
inning_runrate = deliveries.groupby(['inning_type', 'over'])['total_runs'].mean().reset_index()

plt.figure(figsize=(10, 5))
sns.lineplot(data=inning_runrate, x='over', y='total_runs', hue='inning_type', marker='o')
plt.title("Run Rate Comparison: Chasing vs. Defending")
plt.xlabel("Over")
plt.ylabel("Average Runs per Over")
plt.grid(True)
plt.tight_layout()
plt.show()



""" **Match Result Prediction (ML Model)**


"""

print("Match data shape:", match_data.shape)
print("Columns in match_data:", match_data.columns.tolist())

match_data = match_data.dropna(subset=[col for col in match_data.columns if col.startswith("pp_")])

# Merge powerplay scores into match info
merged = match_info.merge(pp_scores, on='match_id')

# Pivot so each match has two rows ‚Üí want wide format (columns per team)
pp_pivot = merged.pivot(index='match_id', columns='batting_team', values='powerplay_runs')

# Instead of dropping all rows with any missing pp_, drop only those missing most important ones
non_null_pp = [col for col in match_data.columns if col.startswith("pp_")]
print("Powerplay columns:", non_null_pp)

# Drop only if ALL powerplay columns are null
match_data = match_data.dropna(subset=non_null_pp, how='all')

print("Powerplay scores (first 5 rows):")
print(pp_scores.head())

print("Merged data before pivot (first 5 rows):")
print(merged.head())

print("Unique batting teams per match (should be 2):")
print(merged.groupby('match_id')['batting_team'].nunique().value_counts())





"""**Team vs Team Head-to-Head Stats**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

matches = pd.read_csv('matches.csv')  # columns: team1, team2, winner, toss_winner, toss_decision, city, venue, etc.
deliveries = pd.read_csv('deliveries.csv')  # optional for batting first/second averages

def sort_teams(row):
    teams = sorted([row['team1'], row['team2']])
    return f"{teams[0]} vs {teams[1]}"

matches['matchup'] = matches.apply(sort_teams, axis=1)

head_to_head = matches.groupby(['matchup', 'winner']).size().unstack(fill_value=0)
head_to_head = head_to_head.reset_index()
print(head_to_head.head())

head_to_head.set_index('matchup').plot(kind='bar', stacked=True, figsize=(14,6), colormap='tab20')
plt.title("Head-to-Head Win Count Between Teams")
plt.ylabel("Match Wins")
plt.xlabel("Matchup")
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

# Tag innings with first/second
innings_total = deliveries.groupby(['match_id', 'inning'])['total_runs'].sum().reset_index()

# Merge team and match info
inning_team = deliveries.groupby(['match_id', 'inning'])['batting_team'].first().reset_index()
innings_total = innings_total.merge(inning_team, on=['match_id', 'inning'])

# Merge with match winner data
innings_total = innings_total.merge(matches[['id', 'team1', 'team2', 'winner']], left_on='match_id', right_on='id')

# Tag as 1st or 2nd innings
innings_total['innings_type'] = innings_total['inning'].apply(lambda x: 'First Innings' if x == 1 else 'Second Innings')

avg_scores = innings_total.groupby(['batting_team', 'innings_type'])['total_runs'].mean().unstack()

avg_scores.plot(kind='bar', figsize=(12,6), colormap='Set2')
plt.title("Average Runs: First vs Second Innings per Team")
plt.ylabel("Average Score")
plt.xlabel("Team")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Overall wins per team
team_wins = matches['winner'].value_counts().reset_index()
team_wins.columns = ['team', 'wins']

# Radial Plot
plt.figure(figsize=(8,8))
ax = plt.subplot(111, polar=True)

theta = [2 * 3.1415 * i / len(team_wins) for i in range(len(team_wins))]
radii = team_wins['wins']
bars = ax.bar(theta, radii, tick_label=team_wins['team'])

ax.set_title("Total Wins per Team (Radial Chart)", va='bottom')
plt.show()



"""**Super Over & Nail-Biter Matches**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Convert result margin to numeric (some may be missing)
matches['result_margin'] = pd.to_numeric(matches['result_margin'], errors='coerce')

# Define close matches: win by <5 runs or by 1 wicket
close_games = matches[((matches['result'] == 'runs') & (matches['result_margin'] <= 5)) |
                      ((matches['result'] == 'wickets') & (matches['result_margin'] <= 1))]

print(f"Total close matches: {close_games.shape[0]}")
print(close_games[['id', 'team1', 'team2', 'winner', 'result', 'result_margin']].head())

# Super Over
super_over_games = matches[matches['super_over'] == True]
print(f"\nSuper Over Matches:\n{super_over_games[['id', 'team1', 'team2', 'winner']]}")

# DLS Method
dls_games = matches[matches['method'].notna()]
print(f"\nDLS Method Matches:\n{dls_games[['id', 'team1', 'team2', 'winner', 'method']]}")

# Get match IDs of close games
close_ids = close_games['id'].unique()

# Filter deliveries from those matches
close_deliveries = deliveries[deliveries['match_id'].isin(close_ids)]

# Top run scorers in close matches
top_batters = close_deliveries.groupby('batter')['batsman_runs'].sum().sort_values(ascending=False).head(10)
print("\nTop Batters in Close Matches:")
print(top_batters)

# Top wicket-takers
wickets_df = close_deliveries[close_deliveries['dismissal_kind'].notna()]
top_bowlers = wickets_df.groupby('bowler')['player_dismissed'].count().sort_values(ascending=False).head(10)
print("\nTop Bowlers in Close Matches:")
print(top_bowlers)

# Batters
plt.figure(figsize=(10, 5))
sns.barplot(x=top_batters.values, y=top_batters.index, palette='Spectral')
plt.title('üèè Top Batters in Close Matches')
plt.xlabel('Runs Scored')
plt.ylabel('Batter')
plt.show()

# Bowlers
plt.figure(figsize=(10, 5))
sns.barplot(x=top_bowlers.values, y=top_bowlers.index, palette='coolwarm')
plt.title('üéØ Top Bowlers in Close Matches')
plt.xlabel('Wickets Taken')
plt.ylabel('Bowler')
plt.show()



"""**Season-Level Trends**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Get first innings total score per match
first_innings = deliveries[deliveries['inning'] == 1]
match_scores = first_innings.groupby('match_id')['total_runs'].sum().reset_index()

# Merge with season info
match_scores = match_scores.merge(matches[['id', 'season']], left_on='match_id', right_on='id')

# Average first innings score by season
avg_score_by_season = match_scores.groupby('season')['total_runs'].mean().reset_index()

# Plot
plt.figure(figsize=(12, 6))
sns.lineplot(x='season', y='total_runs', data=avg_score_by_season, marker='o')
plt.title('üìà Average First Innings Score per Season')
plt.xlabel('Season')
plt.ylabel('Avg First Innings Score')
plt.grid(True)
plt.show()

# Add rule change annotations manually
rule_changes = {
    2008: "Inaugural IPL",
    2011: "2 New Teams",
    2015: "2 Bouncers/Over Allowed",
    2018: "DRS Introduced",
    2022: "2 Bouncers + 2 New Teams"
}

for year, rule in rule_changes.items():
    plt.axvline(x=year, color='red', linestyle='--', alpha=0.5)
    plt.text(year + 0.1, avg_score_by_season['total_runs'].max() - 5, rule, rotation=90, fontsize=9)

plt.show()

# Count number of wins per season per team
team_wins = matches.groupby(['season', 'winner']).size().reset_index(name='wins')

# Plot for selected teams
selected_teams = ['Mumbai Indians', 'Chennai Super Kings', 'Royal Challengers Bangalore']

plt.figure(figsize=(12, 6))
for team in selected_teams:
    team_data = team_wins[team_wins['winner'] == team]
    plt.plot(team_data['season'], team_data['wins'], marker='o', label=team)

plt.title('üìä Team Wins Per Season')
plt.xlabel('Season')
plt.ylabel('Wins')
plt.legend()
plt.grid(True)
plt.show()

# Filter for Kohli
kohli_data = deliveries[deliveries['batter'] == 'V Kohli']

# Add season info
kohli_data = kohli_data.merge(matches[['id', 'season']], left_on='match_id', right_on='id')

# Total runs per season
kohli_runs = kohli_data.groupby('season')['batsman_runs'].sum().reset_index()

# Plot
plt.figure(figsize=(10, 5))
sns.lineplot(x='season', y='batsman_runs', data=kohli_runs, marker='o', label='V Kohli')
plt.title('üèè Virat Kohli - Runs Per Season')
plt.xlabel('Season')
plt.ylabel('Runs')
plt.grid(True)
plt.show()



